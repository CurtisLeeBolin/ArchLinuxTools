use std::io::{BufRead, BufReader};
use std::process::Command;
use std::{env, thread, time};

fn main() {
    let args: Vec<String> = env::args().collect();
    let user_agent = "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36)";
    let urls_string = &args[1];
    let urls: Vec<_> = urls_string.split_whitespace().collect();

    for url in urls.iter() {
        let mut while_status = true;
        while while_status {
            let mut child = Command::new("curl")
                .arg("-C")
                .arg("-")
                .arg("--location")
                .arg("--fail")
                .arg("--remote-name-all")
                .arg("--user-agent")
                .arg(user_agent)
                .arg(url)
                //.stderr(Stdio::inherit())
                .spawn()
                .unwrap();

            let stderr = BufReader::new(child.stderr.take().unwrap());

            let mut stderr_string = String::from("");
            let thread = thread::spawn(move || {
                stderr.lines().for_each(|line| {
                    println!("{}", line.unwrap());
                    stderr_string.push_str(&line.unwrap());
                });
            });

            thread.join().unwrap();

            if child.wait().unwrap().success() {
                while_status = false;
            } else {
                //let stderr_string = String::from_utf8_lossy(&stderr);
                let stderr_string_copy = stderr_string.clone();
                if stderr_string_copy.contains("The requested URL returned error: 416") {
                    while_status = false;
                } else {
                    thread::sleep(time::Duration::from_secs(5));
                    println!();
                }
            }
        }
    }
}
